------ check.lua

-- check_field
    "spaces[%q].format[%d]: invalid type" .. " (table expected, got %s)"

    "spaces[%q].format[%d].name: invalid type" .. " (string expected, got %s)"

    "spaces[%q].format[%q].is_nullable: invalid type" .. " (boolean expected, got %s)"

    "spaces[%q].format[%q].type: invalid type" .. " (string expected, got %s)",

    "spaces[%q].format[%q].type: unknown type %q",

    "spaces[%q].format[%q].type: varbinary type isn't allowed in your Tarantool version (%s)",

    "spaces[%q].format[%q]: redundant key %q",


-- check_index_part_path

    "invalid type" .. " (string expected, got %s)",

    "path (%s) referencing to unknown field",

    "path (%s) is JSONPath, but your Tarantool version (%s) doesn't support this",

    "JSONPath (%s) has wildcard, but your Tarantool version (%s) doesn't support this",

    "JSONPath (%s) has wildcard, but index type %s doesn't allow this",

-- check_index_part_type

    "invalid type (string expected, got %s)",

    "unknown type %q",

    "varbinary type isn't allowed in your Tarantool version (%s)",

    "%s field type is unsupported in %s index type"


-- check_index_part_collation

    "invalid type (?string expected, got %s)",

    "unknown collation %q"


-- check_index_part

    "spaces[%q].indexes[%q].parts[%q]: invalid type" .. " (table expected, got %s)",

    "spaces[%q].indexes[%q].parts[%d].path: %s",

    "spaces[%q].indexes[%q].parts[%d].type: %s",

    "spaces[%q].indexes[%q].parts[%d].type: type differs" ..
    " from spaces[%q].format[%q].type (%s expected, got %s)",

    "spaces[%q].indexes[%q].parts[%d].collation: %s",

    "spaces[%q].indexes[%q].parts[%d].collation: type %s doesn't allow collation (only string type does)",

    "spaces[%q].indexes[%q].parts[%d].is_nullable: invalid type (boolean expected, got %s)",

    "spaces[%q].indexes[%q].parts[%d].is_nullable: has different nullability with " ..
    "spaces[%q].format[%q].is_nullable (%s expected, got %s)",

    "spaces[%q].indexes[%q].parts[%d]: redundant key %q",

-- check_index_parts

    "spaces[%q].indexes[%q].parts: invalid type" .. " (contiguous array of tables expected, got %s)",

    "spaces[%q].indexes[%q].parts[%d]: " .. "field %q is already indexed in parts[%d]",

-- check_index

    "spaces[%q].indexes[%d]: invalid type " .. "(table expected, got %s)",

    "spaces[%q].indexes[%d].name: invalid type" .. " (string expected, got %s)",

    "spaces[%q].indexes[%q].unique: invalid type" .. " (boolean expected, got %s)",

    "spaces[%q].indexes[%q].type: invalid type" .. " (string expected, got %s)",

    "spaces[%q].indexes[%q].type: unknown type %q",

    "spaces[%q].indexes[%q]: %s engine doesn't support %s index type",

    "spaces[%q].indexes[%q]: primary TREE index must be unique",

    "spaces[%q].indexes[%q]: HASH index must be unique",

    "spaces[%q].indexes[%q]: RTREE index can't be primary",

    "spaces[%q].indexes[%q]: RTREE index can't be unique",

    "spaces[%q].indexes[%q].dimension: invalid type" .. " (number in range [1, 20] expected, got %s)",

    "spaces[%q].indexes[%q].dimension: incorrect value" .. " (must be in range [1, 20], got %d)",

    "spaces[%q].indexes[%q].distance: invalid type" .. " (string expected, got %s)",

    "spaces[%q].indexes[%q].distance: unknown distance %q",

    "spaces[%q].indexes[%q]: BITSET index can't be primary",

    "spaces[%q].indexes[%q]: BITSET index can't be unique",

    "spaces[%q].indexes[%q].parts: " .. "index of %s type can't be composite " .. "(currently, index contains %d parts)",

    "spaces[%q].indexes[%q].parts[%d]: " .. "index of %s type doesn't support nullable fields",

    "spaces[%q].indexes[%q].parts[%d].path: primary index" .. " doesn't allow JSONPath wildcard (path %s has wildcard)",

    "spaces[%q].indexes[%q].parts[%d].is_nullable: primary index" .." can't contain nullable parts",

    "spaces[%q].indexes[%q]: redundant key %q",


-- check_sharding_key

    "spaces[%q].format[%q]: bucket_id is used for sharding, " .. "but there's no spaces[%q].sharding_key defined",

    "spaces[%q].indexes[%q]: bucket_id is used for sharding, " .. "but there's no spaces[%q].sharding_key defined",

    "spaces[%q].format: sharding_key exists in the space, but there's" .. " no bucket_id defined in 'format' section",

    [[spaces[%q].format["bucket_id"].type: invalid type (unsigned expected, got %s)]],

    "spaces[%q].indexes: sharding_key exists in the space, but there's" .. " no bucket_id defined in 'indexes' section",

    "spaces[%q].indexes[%q].unique: bucket_id index can't be unique",

    [[spaces[%q].indexes["bucket_id"].parts: bucket_id index can't be composite (1 part expected, got %d parts)]],

    [[spaces[%q].indexes["bucket_id"].parts[1].path: invalid field reference ]] .."(reference to bucket_id expected, got %s)",


    "spaces[%q].sharding_key: invalid type (contiguous array expected, got %s)",

    'spaces[%q].sharding_key: sharding key contains duplicate %q',

    "spaces[%q].sharding_key[%q]: key containing JSONPath isn't supported yet",

    "spaces[%q].sharding_key[%q]: invalid reference to format[%q], no such field",

    "spaces[%q].sharding_key[%q]: key references to field " .. "with %s type, but it's not supported yet"

-- check space

    'spaces[%s]: invalid space name (string expected, got %s)',

    'spaces[%q]: invalid type (table expected, got %s)',

    "spaces[%q].engine: invalid type" .. " (string expected, got %s)",

    "spaces[%q].engine: unknown engine %q",

    "spaces[%q].is_local: invalid type" .. " (boolean expected, got %s)",

    "spaces[%q].temporary: invalid type" .. " (boolean expected, got %s)",

    "spaces[%q]: vinyl engine doesn't support temporary spaces",

    "spaces[%q].format: invalid type" .. " (contiguous array expected, got %s)",

    "spaces[%q].format[%d].name: this space already has field with name %q",

    "spaces[%q].indexes: invalid type" .. " (contiguous array expected, got %s)",

    "spaces[%q].indexes[%d].name: this space already has index with name %q",

    "spaces[%q]: redundant key %q",


--------- set.lua

-- create_space

 "spaces[%q]: %s"

 'spaces[%q]: 'indexes' section is missing (nil)'

 'spaces[%q].indexes[%q]: %s'

 "spaces[%q].sharding_key: %s"

-------- ddl.lua

-- check_schema_format

 'Invalid schema (table expected, got %s)'

 'spaces: must be a table, got %s'


-- check_schema

 "'box' module isn't configured yet"

 "Instance is read-only (box.cfg.read_only=true)"

 "Incompatible schema: spaces[%q]" .. " %s (expected %s, got %s)"

